<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>周的小站</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chzhou.cc/"/>
  <updated>2018-06-04T15:28:44.331Z</updated>
  <id>http://chzhou.cc/</id>
  
  <author>
    <name>Zhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>creation code, input data, solc编译出来的code，这三种code有什么区别</title>
    <link href="http://chzhou.cc/2018/06/04/creation-code-input-data-solc%E7%BC%96%E8%AF%91%E5%87%BA%E6%9D%A5%E7%9A%84code%EF%BC%8C%E8%BF%99%E4%B8%89%E7%A7%8Dcode%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <id>http://chzhou.cc/2018/06/04/creation-code-input-data-solc编译出来的code，这三种code有什么区别/</id>
    <published>2018-06-04T15:27:11.000Z</published>
    <updated>2018-06-04T15:28:44.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三种code"><a href="#三种code" class="headerlink" title="三种code"></a>三种code</h2><ul><li><p>creation code</p><ul><li>在后添加了Constructor Arguments </li></ul></li><li><p>input data</p><ul><li><p>在用命令创建contract的时候需要输入的data</p></li><li><p>格式为bin</p></li><li><p><a href="https://medium.com/@gus_tavo_guim/deploying-a-smart-contract-the-hard-way-8aae778d4f2a" target="_blank" rel="noopener">根据这个blog</a>和<a href="https://github.com/ethereum/go-ethereum/wiki/Contract-Tutorial" target="_blank" rel="noopener">Geth文档</a>，Solc编译出来的bin code作为参数传入创建合约的命令中。</p><ul><li><p>Medium blog</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deployTransationObject = &#123; <span class="attr">from</span>: eth.accounts[<span class="number">0</span>], <span class="attr">data</span>: storageBinCode, <span class="attr">gas</span>: <span class="number">1000000</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> storageInstance = storageContract.new(deployTransationObject)</span><br></pre></td></tr></table></figure></li><li><p>Geth 文档</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greeter = greeterContract.new(_greeting,&#123;<span class="attr">from</span>:web3.eth.accounts[<span class="number">0</span>], <span class="attr">data</span>: greeterCompiled.greeter.code, <span class="attr">gas</span>: <span class="number">1000000</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e, contract</span>)</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p>solc</p><ul><li>solc的关于编译的有两个arguments，其中一个是 <code>--bin</code>，解释为Binary of the contracts in hex，另外一个是<code>--bin-runtime</code>，解释为Binary of the runtime part of the contracts in hex。</li><li>根据这个<a href="https://ethereum.stackexchange.com/questions/13086/solc-bin-vs-bin-runtime" target="_blank" rel="noopener">回答</a>，<code>--bin-runtime</code> is the code that is actually placed on the blockchain. The regular <code>--bin</code> output is the code placed on the blockchain <strong>plus</strong> the code needed to get this code placed on the blockchain</li><li>上面的Medium blog是调用了<code>--bin</code> 命令，而Geth官方文档用的是web3.eth.compile.solidity命令，推测也应该用的是<code>--bin</code>。（未证实）</li></ul></li></ul><h2 id="后续进展"><a href="#后续进展" class="headerlink" title="后续进展"></a>后续进展</h2><ul><li><p>creation code 与 input data</p><p>在Etherscan上寻找几个verified的合约进行验证，得出<strong>creation code</strong>和<strong>input data</strong>是完全一致的。代码由<strong>三部分</strong>组成，第一部分是前面的一些数字，代表着初始化合约的init过程。第二部分是合约的主体过程。第三部分是合约的Constructor Arguments，被添加到了最后。</p></li><li><p>solc</p><p>在stack exchange上进行了<a href="https://ethereum.stackexchange.com/questions/50180/whats-the-contract-creation-code-in-etherscan-verfied-contract" target="_blank" rel="noopener">提问</a>，问题是creation code和solc编译出来的code有何区别。回答是Contract Creation Code is the full bytecode from what contract was deployed, <strong>including constructor parameters</strong>。如果合约没有constructor parameters的话，那么这两种code都是一致的。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://etherscancom.freshdesk.com/support/solutions/articles/35000022165-contract-verification-constructor-arguments" target="_blank" rel="noopener">https://etherscancom.freshdesk.com/support/solutions/articles/35000022165-contract-verification-constructor-arguments</a></p></li><li><p><a href="https://ethereum.stackexchange.com/questions/13086/solc-bin-vs-bin-runtime" target="_blank" rel="noopener">https://ethereum.stackexchange.com/questions/13086/solc-bin-vs-bin-runtime</a></p></li><li><p><a href="https://medium.com/@gus_tavo_guim/deploying-a-smart-contract-the-hard-way-8aae778d4f2a" target="_blank" rel="noopener">https://medium.com/@gus_tavo_guim/deploying-a-smart-contract-the-hard-way-8aae778d4f2a</a></p></li><li><p><a href="https://github.com/ethereum/go-ethereum/wiki/Contract-Tutorial" target="_blank" rel="noopener">https://github.com/ethereum/go-ethereum/wiki/Contract-Tutorial</a></p></li><li><p><a href="https://ethereum.stackexchange.com/questions/50180/whats-the-contract-creation-code-in-etherscan-verfied-contract" target="_blank" rel="noopener">https://ethereum.stackexchange.com/questions/50180/whats-the-contract-creation-code-in-etherscan-verfied-contract</a></p></li><li><p>验证creation code和input data是否一致的几个合约</p><ul><li><a href="https://etherscan.io/address/0xcac337492149bdb66b088bf5914bedfbf78ccc18#code" target="_blank" rel="noopener">https://etherscan.io/address/0xcac337492149bdb66b088bf5914bedfbf78ccc18#code</a></li><li><a href="https://etherscan.io/address/0x7c333b69021b3ad9288d3b0083f9bd27c6d4680a#code" target="_blank" rel="noopener">https://etherscan.io/address/0x7c333b69021b3ad9288d3b0083f9bd27c6d4680a#code</a></li><li><a href="https://etherscan.io/address/0x233d2daad4018fae14c69b2830bf97057c7fb1b5#code" target="_blank" rel="noopener">https://etherscan.io/address/0x233d2daad4018fae14c69b2830bf97057c7fb1b5#code</a></li></ul><p>注：这三个合约的最后都有Constructor Arguments ，不知这个有没有影响导致两种code一致。但是现在比较新的合约在verify的时候都需要提供Constructor Arguments，所以就不加考虑这个因素以及旧的没有Constructor Arguments的合约。</p><p>注：在最新的verified contract里面，检查了最新的前三个合约的两种code，是完全一致的。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;三种code&quot;&gt;&lt;a href=&quot;#三种code&quot; class=&quot;headerlink&quot; title=&quot;三种code&quot;&gt;&lt;/a&gt;三种code&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;creation code&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在后添加了Constructor A
      
    
    </summary>
    
    
      <category term="ETH" scheme="http://chzhou.cc/tags/ETH/"/>
    
  </entry>
  
  <entry>
    <title>DeepLab v3+: prediction out of bound</title>
    <link href="http://chzhou.cc/2018/05/31/DeepLab-v3-predition-out-of-bound/"/>
    <id>http://chzhou.cc/2018/05/31/DeepLab-v3-predition-out-of-bound/</id>
    <published>2018-05-31T15:57:48.000Z</published>
    <updated>2018-05-31T16:02:09.430Z</updated>
    
    <content type="html"><![CDATA[<h2 id="出现情景"><a href="#出现情景" class="headerlink" title="出现情景"></a>出现情景</h2><p>最近在用DeepLab v3+ 训练模型，已经训练好了自己的数据集。可是在验证的时候，程序总是报错。抛出<code>prediction out of bound</code> 的错误。意思很好理解，就是预测超出了范围。但是范围是什么呢？又是如何超出的呢？经过搜索，找出了答案。</p><h2 id="文件代码"><a href="#文件代码" class="headerlink" title="文件代码"></a>文件代码</h2><p>在/deeplab/datasets文件夹下，有一个名为 <em>segmentation_dataset.py</em> 的文件。在该文件夹里，就定义了训练集和验证集的信息。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_PASCAL_VOC_SEG_INFORMATION = DatasetDescriptor(</span><br><span class="line">    splits_to_sizes=&#123;</span><br><span class="line">        <span class="string">'train'</span>: <span class="number">7</span>,</span><br><span class="line">        <span class="string">'trainval'</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">'val'</span>: <span class="number">3</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    num_classes=<span class="number">8</span>,</span><br><span class="line">    ignore_label=<span class="number">255</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里已经针对自己的数据集进行了修改。其中<code>train</code> 和 <code>val</code>的字段意思就是对应数据集的大小。因为我只是测试，所以这里我的训练集就只有7张，验证集是3张。下面的<code>num_classes</code>和<code>ignore_lable</code>是数据集的类别数目和忽视的类别。而我出问题的就在这个<code>num_classes</code>上。</p><h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>直觉认为这里<code>num_classes</code>就是类别的数目，当然这个想法也是对的。但是这里的前提是<strong>数据集的lable标记是从1开始的</strong>，也就是说，你的类别从1，2，3，…，num_classes这样定义的。但是这个是很反人类的，因为有的时候为了更加直观理解，并不一定从1开始。比如这次百度提供的数据集，车的标记就是33。而我的写的<code>num_classes</code> 是8，自然33要大于8，就抛出了<code>prediction out of bound</code>的错误了。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>在查到这个问题后，将自己的<code>num_classes</code>变成了这次数据集对应的lableID，但是这次百度给的数据集的id是乘以1000的，所以车的id33，就变成了33000。我这样改之后，训练的时候又爆出了<code>OOM</code> 的问题，也就是说训练爆内存了，显然是因为<code>num_classes</code>的数目太大。</p><p>这样就涉及到了修改对应的id问题，也就是说把车的id经过修改变成1。<a href="https://gist.github.com/DrSleep/4bce37254c5900545e6b65f6a0858b9c" target="_blank" rel="noopener">具体的方案在这里</a>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/tensorflow/models/issues/3906中@BillBai的回答" target="_blank" rel="noopener">https://github.com/tensorflow/models/issues/3906中@BillBai的回答</a></li><li><a href="https://gist.github.com/DrSleep/4bce37254c5900545e6b65f6a0858b9c" target="_blank" rel="noopener">https://gist.github.com/DrSleep/4bce37254c5900545e6b65f6a0858b9c</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;出现情景&quot;&gt;&lt;a href=&quot;#出现情景&quot; class=&quot;headerlink&quot; title=&quot;出现情景&quot;&gt;&lt;/a&gt;出现情景&lt;/h2&gt;&lt;p&gt;最近在用DeepLab v3+ 训练模型，已经训练好了自己的数据集。可是在验证的时候，程序总是报错。抛出&lt;code&gt;pred
      
    
    </summary>
    
    
      <category term="DeepLab" scheme="http://chzhou.cc/tags/DeepLab/"/>
    
      <category term="DL" scheme="http://chzhou.cc/tags/DL/"/>
    
      <category term="ML" scheme="http://chzhou.cc/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>获取合约在链上运行的实际Code</title>
    <link href="http://chzhou.cc/2018/05/29/%E8%8E%B7%E5%8F%96%E5%90%88%E7%BA%A6%E5%9C%A8%E9%93%BE%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%9E%E9%99%85Code/"/>
    <id>http://chzhou.cc/2018/05/29/获取合约在链上运行的实际Code/</id>
    <published>2018-05-29T15:59:46.000Z</published>
    <updated>2018-05-29T16:02:14.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>在Etherscan网站上获取到的bytecode，是”Contract Creation Code”，这个code 里面在前面添加了constructor信息。为了比对</p><ul><li>web3.eth.getCode(Address)</li><li>solc编译</li><li>Etherscan网站获取的Contract Creation Code</li></ul><p>这三者的差异，以便为之后的合约检查做准备，需要获得某个合约地址的code。</p><p>在这里，后两种方法很简单。主要遇到的问题在第一个方法。</p><h2 id="Geth客户端内web3调用"><a href="#Geth客户端内web3调用" class="headerlink" title="Geth客户端内web3调用"></a>Geth客户端内web3调用</h2><p>在用web3调用的时候，需要在geth客户端里运行命令。</p><p>首先用<code>geth console</code>命令启动geth，进入console界面。但是通过调用web3的一些诸如获取交易信息，余额等命令，总是返回错误或者0。经过网上查询得知，这是因为geth客户端并没有把所有的主网结点信息下载下来，那么这样调用的结果自然就是错误。</p><p>在服务器上花了一晚上的时间，把主网的所有结点都下载了下来，结果调用后还是返回错误。经过进一步的查询得知，下载数据只是第一步，还有进行交叉验证信息这一步。第二步才是最耗费时间的步骤 。有个网友反映，自己下载所有的结点花了几个小时，结果进行验证这个步骤就花了一周多，并且产生的数据就有220G多。</p><p>所以弃用在geth客户端内进行web3命令的计划。</p><h2 id="Infura-RPC-命令"><a href="#Infura-RPC-命令" class="headerlink" title="Infura + RPC 命令"></a>Infura + RPC 命令</h2><p>上一个步骤中，web3命令之所以不成功，主要是因为没有主网的所有结点信息。那也就是说有了信息后，那就可以调用了。此时，Infura派上用场。</p><blockquote><p>Infura：Infura 提供公开的 Ethereum 主网和测试网络节点</p></blockquote><p>在<a href="https://infura.io/" target="_blank" rel="noopener">Infura</a>官网上进行注册，便获得个人的API，此时不需要自己下载或者连接到主网，通过API访问，便可以取得主网的一切信息。</p><p><img src="https://i.loli.net/2018/05/29/5b0d5a4e3b19f.png" alt="Infura提供的链接.PNG"></p><p>此时已经有了主网结点信息。接下来就是如何使用web3命令。</p><p>web3命令，其实是调用的JSON-RPC。比如<code>web3.eth.getCode</code>， 在JSON-RPC中，对应的就是<code>eth_getCode</code>。所以便可以直接通过调用RPC的命令，就可以达到web3调用命令的目的。</p><p>通过查阅RPC的Doc，得到getCode的命令是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST --data &apos;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_getCode&quot;,&quot;params&quot;:[&quot;0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b&quot;, &quot;0x2&quot;],&quot;id&quot;:1&#125;&apos;</span><br></pre></td></tr></table></figure><p>那么调用就是<code>&quot;RPC命令&quot;+&quot;https://mainnet.infura.io/&lt;YOUR-API-KEY&gt;&quot;</code>，这样就完成了对主网信息的查询。</p><p>附上一个查询当前最新区块的示例命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST --data &apos;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_blockNumber&quot;,&quot;params&quot;:[],&quot;id&quot;:1&#125;&apos; https://mainnet.infura.io/&lt;YOUR-API-KEY&gt;</span><br><span class="line">&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:1,&quot;result&quot;:&quot;0x56ef50&quot;&#125;</span><br></pre></td></tr></table></figure><p>在这里，<code>id</code>为“1”，说明此时连接的网络为主网。返回的result结果是<code>0x56ef50</code>，是16进制，转换成10进制，则值为<code>5697360</code>。正和当前的区块最高高度一致。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p>Infura官网</p><p><a href="https://infura.io/" target="_blank" rel="noopener">https://infura.io/</a></p></li><li><p>web3文档</p><p><a href="https://github.com/ethereum/wiki/wiki/JavaScript-API" target="_blank" rel="noopener">https://github.com/ethereum/wiki/wiki/JavaScript-API</a></p></li><li><p>JSON-RPC文档</p><p><a href="https://github.com/ethereum/wiki/wiki/JSON-RPC" target="_blank" rel="noopener">https://github.com/ethereum/wiki/wiki/JSON-RPC</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;p&gt;在Etherscan网站上获取到的bytecode，是”Contract Creation Code”，这个code 里面在前面添加了con
      
    
    </summary>
    
    
      <category term="ETH" scheme="http://chzhou.cc/tags/ETH/"/>
    
  </entry>
  
  <entry>
    <title>algs4 percolation问题</title>
    <link href="http://chzhou.cc/2017/11/09/algs4-percolation%E9%97%AE%E9%A2%98/"/>
    <id>http://chzhou.cc/2017/11/09/algs4-percolation问题/</id>
    <published>2017-11-09T07:39:40.000Z</published>
    <updated>2017-11-09T09:40:09.476Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何判断这个点阵已经percolate了？"><a href="#如何判断这个点阵已经percolate了？" class="headerlink" title="如何判断这个点阵已经percolate了？"></a>如何判断这个点阵已经percolate了？</h3><p>一个比较trick的解决办法就是引入”virtual top”和”virtual bottom”这两个点。如图所示。</p><p><img src="https://i.loli.net/2017/11/09/5a041187dea72.png" alt="vitual top"></p><p>这样，这个系统是否percolate的问题就转换为虚拟顶部结点能否与虚拟底部结点相连。第一行或者最后一行的点被打开的时候就立马与虚拟结点相连。</p><p>###如何解决backwash问题？</p><p>什么是backwash？backwash问题就是由于虚拟结点的存在，本来一些点是不能被认为是full的（也就是说不能连接到顶部），但是由于其能和虚拟底部结点相连，虚拟底部结点又能通过其他点与顶部相连。这样这个的点在判断的时候就会认为是full的。</p><blockquote><p>In the context of Percolation, the backwash issue is that some site might be mistakenly judged as a full site (A full site is an open site that can be connected to an open site in the top row via a chain of neighboring (left, right, up, down) open sites.) if we directly adopt the dummy nodes suggested in the course material, i.e., a top virtual node connected to each site in the first first top row, another bottom virtual node connected to each site in the last bottom row. [看这个博文][<a href="https://www.sigmainfy.com/blog/avoid-backwash-in-percolation.html]" target="_blank" rel="noopener">https://www.sigmainfy.com/blog/avoid-backwash-in-percolation.html]</a></p></blockquote><p><img src="https://www.sigmainfy.com/images/percolation_backwash.png" alt="backwash"></p><p>在解决这个问题的就是引入两个并查集，一个集合里只包含虚拟顶部结点，另一个集合里包括虚拟顶部和底部结点。这样在判断一个点是不是full的时候，看看这个点在两个集合里能不能连接到顶部结点，或者说在只有虚拟顶部结点里的集合里能不能连接到顶部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line"> validate(row, col); <span class="comment">//判断该坐标合理与否</span></span><br><span class="line"> <span class="keyword">int</span> q = xyTo1d(row, col); <span class="comment">//将二维坐标转换为一维的数组坐标</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (idOnlyTop.connected(q, <span class="number">0</span>)) &#123;       <span class="comment">// id.find(0) == idOnlyTop.find(q)</span></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>###如何存储结点的开关与否信息？</p><p>刚开始做的时候不知道该怎么存储一个结点的开关信息，想了一些办法，总觉得很麻烦。之后通过在晚上查询才得出可以直接创建一个boolean类型的数组，这个点被打开的时候就记该值为true，反之为false。而且要记住刚开始定义的时候这个数组的值就全是false的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] state; <span class="comment">//先定义存储数组开关信息的boolean数组类型</span></span><br><span class="line"></span><br><span class="line">state = <span class="keyword">new</span> <span class="keyword">boolean</span>[n * n + <span class="number">1</span>]; <span class="comment">//进行定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">  validate(row, col);</span><br><span class="line">  <span class="keyword">int</span> i = xyTo1d(row, col);</span><br><span class="line">  state[i] = <span class="keyword">true</span>;</span><br><span class="line">  count++;</span><br><span class="line">  <span class="comment">/* 之后的代码就是把这个点打开后与附近同样打开的点union的过程 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他的一些trick"><a href="#其他的一些trick" class="headerlink" title="其他的一些trick"></a>其他的一些trick</h3><ul><li>因为程序要求在每个输入的时候，对于不合法的输入要抛出异常，所以可以单独建立validate()函数，在每个接受输入的类里第一句就运行这个函数，这样能及时抛出异常。</li><li>输入的时候，输入的是这个点的二维坐标，但是在实际存储的时候所有的点都是在一维数组里存储着，所以可以先建立一个xyTo1d()函数，这样就能快速转换。而不是每次都进行计算。</li></ul><p>理解模块化。对于一些常用到的过程进行封装，成为函数，然后直接通过接口进行引用。代码简洁易懂。而且在写代码的时候也有条例。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;如何判断这个点阵已经percolate了？&quot;&gt;&lt;a href=&quot;#如何判断这个点阵已经percolate了？&quot; class=&quot;headerlink&quot; title=&quot;如何判断这个点阵已经percolate了？&quot;&gt;&lt;/a&gt;如何判断这个点阵已经percolate了？&lt;/
      
    
    </summary>
    
    
      <category term="algs4" scheme="http://chzhou.cc/tags/algs4/"/>
    
  </entry>
  
  <entry>
    <title>algs4第一周 一点时间复杂度</title>
    <link href="http://chzhou.cc/2017/11/08/algs4%E7%AC%AC%E4%B8%80%E5%91%A8%20%E4%B8%80%E7%82%B9%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>http://chzhou.cc/2017/11/08/algs4第一周 一点时间复杂度/</id>
    <published>2017-11-08T13:59:00.000Z</published>
    <updated>2017-11-09T09:40:32.910Z</updated>
    
    <content type="html"><![CDATA[<p>###Quick-find中union( ) 操作性能分析</p><p>书中说明每次union( ) 操作访问数组的次数是（n+3）~ （2n+1）之间。首先先看一下代码块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pid = find(p);</span><br><span class="line">  <span class="keyword">int</span> qid = find(q);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (pid == qid) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (id[i] == pid) &#123;</span><br><span class="line">      id[i] = qid;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>每次调用union（）总会调用find（）两次，这样的话会访问数组2次。</li><li>循环里for循环会执行n次，在判断里会访问数组n次。</li><li>在union（）操作中，至少会有一个数的会被改变，那么就是1次；而最多除了q之外所有的数都要和q连接，那么的话就会有n-1个数的值被改变，就是n-1次。</li></ol><p>综上，union（）操作访问数组的次数在（2+n+1）~（2+n+n-1）也就是（n+3）~（2n+1）次。</p><p>###一个三层嵌套时间复杂度另类数学求法</p><p>从一组数里找出三个数之和为0的组合。代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; n; k++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i] + a[j] + a[k] == <span class="number">0</span>) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅从数学分析，那么该数学模型就是从n个数中抽出3个数，看有几个组合。根据排列组合知识可知，为$ C_n^3$， 展开即为$\frac{n^3}{6}-\frac{n^2}{2}+\frac{n}{3}$。所以时间复杂度为O（$n^3$)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###Quick-find中union( ) 操作性能分析&lt;/p&gt;
&lt;p&gt;书中说明每次union( ) 操作访问数组的次数是（n+3）~ （2n+1）之间。首先先看一下代码块。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
    
      <category term="algs4" scheme="http://chzhou.cc/tags/algs4/"/>
    
      <category term="算法" scheme="http://chzhou.cc/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>离散数学: 1.2 Applications of Propositional Logic</title>
    <link href="http://chzhou.cc/2017/04/24/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%9A1-2-Applications-of-Propositional-Logic/"/>
    <id>http://chzhou.cc/2017/04/24/离散数学：1-2-Applications-of-Propositional-Logic/</id>
    <published>2017-04-24T10:52:01.000Z</published>
    <updated>2017-04-24T12:43:40.110Z</updated>
    
    <content type="html"><![CDATA[<p>从名字可以看出，这一节是对上一节知识的应用。在这一节中，介绍了在搜索引擎中如何利用<code>AND</code>、<code>OR</code>等进行精确查找所需内容，还有一些逻辑谜题、电路实现逻辑运算的内容。整节比较简单易懂。</p><p>[TOC]</p><hr><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><h3 id="2-Translating-English-Sentence"><a href="#2-Translating-English-Sentence" class="headerlink" title="2. Translating English Sentence"></a>2. Translating English Sentence</h3><p>把自然语言翻译为逻辑语言的练习。自然语言具有不精确、磨棱两可、省略许多背景信息的特点，而逻辑语言则要求准确无误，所以在翻译过程中一定要认真，理清关系。</p><h3 id="3-System-Specifications"><a href="#3-System-Specifications" class="headerlink" title="3. System Specifications"></a>3. System Specifications</h3><p>这个小节是说当几个命题组成一个”system”的时候，必须保持“一致性”，不能互相矛盾。</p><h3 id="4-Boolean-Searches"><a href="#4-Boolean-Searches" class="headerlink" title="4. Boolean Searches"></a>4. Boolean Searches</h3><ul><li><code>AND</code>去搜索两个目标都存在的网页。</li><li><code>OR</code>去搜索只要有两者之一或者两者都有的网页。</li><li><code>NOT</code>去搜索两者剔除其中一者的网页。</li></ul><h3 id="5-Logic-Puzzles"><a href="#5-Logic-Puzzles" class="headerlink" title="5. Logic Puzzles"></a>5. Logic Puzzles</h3><p>介绍了几个运用逻辑的小问题，类似于脑筋急转弯。</p><h3 id="6-Logic-Circuits"><a href="#6-Logic-Circuits" class="headerlink" title="6. Logic Circuits"></a>6. Logic Circuits</h3><p>简单介绍了逻辑运算的电路实现形式，分别有“非门”、“或门”、“与门”三种。</p><p><img src="https://ooo.0o0.ooo/2017/04/24/58fdf29745421.png" alt="捕获.PNG"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从名字可以看出，这一节是对上一节知识的应用。在这一节中，介绍了在搜索引擎中如何利用&lt;code&gt;AND&lt;/code&gt;、&lt;code&gt;OR&lt;/code&gt;等进行精确查找所需内容，还有一些逻辑谜题、电路实现逻辑运算的内容。整节比较简单易懂。&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;hr&gt;
      
    
    </summary>
    
    
      <category term="离散数学" scheme="http://chzhou.cc/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>离散数学: 1.1 Propositional Logic</title>
    <link href="http://chzhou.cc/2017/04/24/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%9A1-1-Propositional-Logic/"/>
    <id>http://chzhou.cc/2017/04/24/离散数学：1-1-Propositional-Logic/</id>
    <published>2017-04-24T10:51:07.000Z</published>
    <updated>2017-04-24T13:01:54.871Z</updated>
    
    <content type="html"><![CDATA[<p>这一节是对命题逻辑的入门。其中对我印象最大的是对“异或”的解释，让我不再像以前对“异或”混沌了。</p><p>我就根据书上的目录去进行知识的梳理。</p><p>[TOC]</p><hr><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><h3 id="2-Propositions"><a href="#2-Propositions" class="headerlink" title="2. Propositions"></a>2. Propositions</h3><ul><li>命题的两个要素<ul><li>declarative</li><li>either true or false</li></ul></li><li>“真值”标记为<code>T</code>，“假值”标记为<code>F</code></li><li>Truth Table</li><li>几种基本运算符号<ul><li>p    ﹁p</li><li>p∧q，意为”p and q” </li><li>p∨q，意为”p or q”，这个是”inclusive or”</li><li>p⊕q，意为”p xor q”，这个是”exclusive or”。这里的<code>exclusive</code>即为”排除“之意。书中的解释很好，是”Students who have taken calculus <strong>or</strong> computer science, but <strong>not both</strong>, can enroll in this class.”也就是说只能二取一，但不能都取。这样也就解释了为什么在进行二进制异或计算时，只有<code>0</code>和<code>1</code>在一起才能计算出<code>1</code>，<code>0</code>和<code>0</code> 或者<code>1</code> 和<code>1</code>只能得到<code>0</code></li></ul></li></ul><h3 id="3-Conditional-Statements"><a href="#3-Conditional-Statements" class="headerlink" title="3. Conditional Statements"></a>3. Conditional Statements</h3><ul><li><p>p→q</p><ul><li><p>if p, then q</p></li><li><p>p is hypothesis, q is conclusion</p></li><li><p>statement is False when p is true and q is false, and True otherwise</p><p>（陈述的真值表书中的解释很完美，是这样解释的：选举人在竞选时说：“if我当选了，then我就会降低税率”。倘若这个选举人真的竞选成功了，那么人们就会期待他降低税率。但是他没有降低税率，这样我们此时就能说这个陈述是假的。其他情况我们都只能说时真的，无论这个选举人有无竞选上。）</p></li><li><p>等价的表述还有<code>p only if q</code>和<code>q unless ﹁p</code>（从真值表去证明）</p></li></ul></li><li><p>三个变化</p></li></ul><table><thead><tr><th style="text-align:center">converse</th><th style="text-align:center">q→p</th></tr></thead><tbody><tr><td style="text-align:center">inverse</td><td style="text-align:center">﹁p→﹁q</td></tr><tr><td style="text-align:center">contrapositive</td><td style="text-align:center">﹁q→﹁p</td></tr></tbody></table><ul><li>p↔q</li></ul><h3 id="4-Truth-Table-of-Compound-Propositions"><a href="#4-Truth-Table-of-Compound-Propositions" class="headerlink" title="4. Truth Table of Compound Propositions"></a>4. Truth Table of Compound Propositions</h3><h3 id="5-Precedence-of-Logical-Operators"><a href="#5-Precedence-of-Logical-Operators" class="headerlink" title="5. Precedence of Logical Operators"></a>5. Precedence of Logical Operators</h3><p>各种运算符号的优先级。</p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">优先级</th></tr></thead><tbody><tr><td style="text-align:center">﹁</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">∧</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">∨</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">→</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">↔</td><td style="text-align:center">5</td></tr></tbody></table><h3 id="6-Logic-and-Bit-Operations"><a href="#6-Logic-and-Bit-Operations" class="headerlink" title="6. Logic and Bit Operations"></a>6. Logic and Bit Operations</h3><ul><li>二进制表示时，<code>1</code>表示<code>T</code>，<code>0</code>表示<code>F</code></li><li><code>AND</code>为<code>∧</code>, <code>OR</code>为<code>∨</code>,<code>XOR</code>为<code>⊕</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一节是对命题逻辑的入门。其中对我印象最大的是对“异或”的解释，让我不再像以前对“异或”混沌了。&lt;/p&gt;
&lt;p&gt;我就根据书上的目录去进行知识的梳理。&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;1-Introduction&quot;&gt;&lt;a href=&quot;#1-Intr
      
    
    </summary>
    
    
      <category term="离散数学" scheme="http://chzhou.cc/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
</feed>
